{\rtf1\ansi\ansicpg1252\cocoartf2639
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 HelveticaNeue;\f1\fnil\fcharset0 Monaco;\f2\fnil\fcharset0 HelveticaNeue-Medium;
}
{\colortbl;\red255\green255\blue255;\red42\green49\blue64;\red245\green245\blue246;}
{\*\expandedcolortbl;;\cssrgb\c21569\c25490\c31765;\cssrgb\c96863\c96863\c97255;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{none\}}{\leveltext\leveltemplateid1\'00;}{\levelnumbers;}\fi-360\li720\lin720 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid2\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li1440\lin1440 }{\listname ;}\listid1}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}}
\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\sa400\partightenfactor0

\f0\fs32 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 In Flutter, both 
\f1\fs28 FutureBuilder
\f0\fs32  and 
\f1\fs28 StreamBuilder
\f0\fs32  are widget classes that allow you to build your UI based on asynchronous data. They provide a way to handle the state and update the UI automatically when the data becomes available or changes.\
Here's the difference between 
\f1\fs28 FutureBuilder
\f0\fs32  and 
\f1\fs28 StreamBuilder
\f0\fs32 :\
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls1\ilvl0
\f2\b \cf2 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 		\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Data source
\f0\b0 :\cb1 \
\pard\tx940\tx1440\pardeftab720\li1440\fi-1440\partightenfactor0
\ls1\ilvl1
\f1\fs28 \cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 FutureBuilder
\f0\fs32  is used when you have a single asynchronous operation that returns a single result, typically a 
\f1\fs28 Future
\f0\fs32  object.\cb1 \
\ls1\ilvl1
\f1\fs28 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 StreamBuilder
\f0\fs32  is used when you have a continuous stream of asynchronous data, typically a 
\f1\fs28 Stream
\f0\fs32  object.\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls1\ilvl0
\f2\b \cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 		\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Data availability
\f0\b0 :\cb1 \
\pard\tx940\tx1440\pardeftab720\li1440\fi-1440\partightenfactor0
\ls1\ilvl1
\f1\fs28 \cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 FutureBuilder
\f0\fs32  expects a future to complete and provide a value once. It waits for the future to resolve and rebuilds the UI with the data when it becomes available.\cb1 \
\ls1\ilvl1
\f1\fs28 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 StreamBuilder
\f0\fs32  listens to a stream and rebuilds the UI every time new data arrives in the stream. It handles multiple data events over time.\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls1\ilvl0
\f2\b \cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 		\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Widget tree update
\f0\b0 :\cb1 \
\pard\tx940\tx1440\pardeftab720\li1440\fi-1440\partightenfactor0
\ls1\ilvl1
\f1\fs28 \cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 FutureBuilder
\f0\fs32  triggers a rebuild of the widget tree once the future completes. This means the entire widget tree under 
\f1\fs28 FutureBuilder
\f0\fs32  will be rebuilt.\cb1 \
\ls1\ilvl1
\f1\fs28 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 StreamBuilder
\f0\fs32  triggers a rebuild of the widget tree whenever new data is emitted by the stream. Only the portion of the widget tree wrapped by 
\f1\fs28 StreamBuilder
\f0\fs32  will be rebuilt.\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls1\ilvl0
\f2\b \cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 		\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Data handling
\f0\b0 :\cb1 \
\pard\tx940\tx1440\pardeftab720\li1440\fi-1440\partightenfactor0
\ls1\ilvl1
\f1\fs28 \cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 FutureBuilder
\f0\fs32  takes a 
\f1\fs28 Future
\f0\fs32  and expects a single value or an error. It provides snapshots of the asynchronous task's lifecycle (waiting, error, done) through the 
\f1\fs28 AsyncSnapshot
\f0\fs32  object.\cb1 \
\ls1\ilvl1
\f1\fs28 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 StreamBuilder
\f0\fs32  takes a 
\f1\fs28 Stream
\f0\fs32  and can handle multiple values over time. It provides snapshots of the asynchronous stream's lifecycle (waiting, active, error, done) through the 
\f1\fs28 AsyncSnapshot
\f0\fs32  object.\cb1 \
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 In summary, 
\f1\fs28 FutureBuilder
\f0\fs32  is used for handling a one-time asynchronous operation, while 
\f1\fs28 StreamBuilder
\f0\fs32  is used for managing a continuous stream of asynchronous data.\
}